use std::io;
use std::ptr::NonNull;

use super::{CompletionQueue, resultify};

/// A completed IO event.
pub struct CQE {
    user_data: u64,
    res: i32,
    flags: CompletionFlags,
}

impl CQE {
    pub fn from_raw(cqe: uring_sys::io_uring_cqe) -> CQE {
        CQE {
            user_data: cqe.user_data,
            res: cqe.res,
            flags: CompletionFlags::from_bits_truncate(cqe.flags),
        }
    }

    pub fn from_raw_parts(user_data: u64, res: i32, flags: CompletionFlags) -> CQE {
        CQE {
            user_data, res, flags,
        }
    }

    pub(crate) fn new(ring: NonNull<uring_sys::io_uring>, cqe: &mut uring_sys::io_uring_cqe) -> CQE {
        let user_data = cqe.user_data;
        let res = cqe.res;
        let flags = CompletionFlags::from_bits_truncate(cqe.flags);

        unsafe {
            uring_sys::io_uring_cqe_seen(ring.as_ptr(), cqe);
        }

        CQE::from_raw_parts(user_data, res, flags)
    }

    /// Check whether this event is a timeout generated by this crate.
    /// ```
    /// # use iou::{IoUring, SQE, CQE};
    /// # fn main() -> std::io::Result<()> {
    /// # let mut ring = IoUring::new(2)?;
    /// # let mut sqe = ring.prepare_sqe().unwrap();
    /// #
    /// # // make a nop for testing
    /// # unsafe { sqe.prep_nop(); }
    /// # ring.submit_sqes()?;
    /// #
    /// # let mut cq_event;
    /// cq_event = ring.wait_for_cqe()?;
    /// # // rewrite to be a fake timeout
    /// # let cq_event = CQE::from_raw_parts(uring_sys::LIBURING_UDATA_TIMEOUT, 0, 0);
    /// assert!(cq_event.is_iou_timeout());
    /// # Ok(())
    /// # }
    /// ```
    pub fn is_iou_timeout(&self) -> bool {
        self.user_data == uring_sys::LIBURING_UDATA_TIMEOUT
    }

    pub fn user_data(&self) -> u64 {
        self.user_data as u64
    }

    pub fn result(&self) -> io::Result<u32> {
        resultify(self.res)
    }

    pub fn flags(&self) -> CompletionFlags {
        self.flags
    }

    pub fn raw_result(&self) -> i32 {
        self.res
    }

    pub fn raw_flags(&self) -> u32 {
        self.flags.bits()
    }
}

unsafe impl Send for CQE { }
unsafe impl Sync for CQE { }

pub struct CQEs<'a, 'b> {
    pub(crate) queue: &'b mut CompletionQueue<'a>,
    pub(crate) ready: u32,
}

impl Iterator for CQEs<'_, '_> {
    type Item = CQE;

    fn next(&mut self) -> Option<Self::Item> {
        if self.ready == 0 {
            self.ready = self.queue.ready();
            if self.ready == 0 {
                return None;
            }
        }

        self.ready -= 1;
        self.queue.peek_for_cqe()
    }
}

pub struct CQEsBlocking<'a, 'b> {
    pub(crate) queue: &'b mut CompletionQueue<'a>,
    pub(crate) ready: u32,
}

impl Iterator for CQEsBlocking<'_, '_> {
    type Item = io::Result<CQE>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.ready == 0 {
            self.ready = self.queue.ready();
            if self.ready == 0 {
                return Some(self.queue.wait_for_cqe());
            }
        }

        self.ready -= 1;
        self.queue.peek_for_cqe().map(Ok)
    }
}

bitflags::bitflags! {
    pub struct CompletionFlags: u32 {
        const BUFFER_SHIFT    = 1 << 0;
    }
}
